---
title: "CIBERlite"
author: "Gjalt-Jorn Peters & Rik Crutzen"
date: "`r format(Sys.time(), '%H:%M:%S on %Y-%m-%d %Z (GMT%z)')`"
output: html_document
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE);
options(ufs.debug = FALSE);

require('userfriendlyscience');
safeRequire('here');
safeRequire('data.tree');
safeRequire('tidyverse');
safeRequire('gridExtra');
safeRequire('readODS');

dataPath <- here::here('results-data-raw');
processedDataPath <- here::here('results-data-processed');

privateOUdataFileRegEx <- 'survey_722821_R_data_file_\\[PRIVATE-OU-version]';
publicOUdataFileRegEx <- 'survey_722821_R_data_file_\\[PUBLIC-OU-version]';
OUdataLoadScriptName <- 'survey_722821_R_syntax_file_[OU-version].R';

ondrzkDataFileRegEx <- 'survey_722821_R_data_file_\\[ondrzk-version]';
ondrzkDataLoadScriptName <- 'survey_722821_R_syntax_file_[ondrzk-version].R';

categoricalQuestions <- c('sex',
                          'education');

dataDeletionVarCode <- "dataMustBeDeleted";
dataDeletionSubQuestionCode <- "delete";
dataDeletionVarValue <- "2";
privateFileIdentificationString <- "PRIVATE-";
publicFileIdentificationString <- "PUBLIC-";

behaviors <- c("coffee", "publicTransport",
               "runRedLight", "wasteSeparation",
               "conSomebody", "marathon",
               "longShower", "brushingTeeth");

detStruct <-
  lapply(behaviors,
         function(behav) {
  return(determinantStructure(behav,
                              list(behaviorRegEx = behav),
                              determinantVar("intention",
                                             "intention",
                                             determinantVar("attitude",
                                                            "att"),
                                             determinantVar("perceivedNorm",
                                                            "pn"),
                                             determinantVar("perceivedBehavioralControl",
                                                            "pbc"))));
});

```



```{r}

########################################################################
###
### Import data from Open University survey
###
########################################################################
###
### First delete the data from students who indicated they want their
### data destroyed (note that this private data file is excluded from
### synchronization with the GitHub repository, and therefore the OSF
### repository, using .gitignore)
###
### Note: if you ever accidently commit private data to git, this can
### be removed using bfg, see:
###
###   https://help.github.com/articles/removing-sensitive-data-from-a-repository/
###   https://rtyley.github.io/bfg-repo-cleaner/
###
### For example, assuming you have version 1.13 installed in the
### directory B:\Apps\bfg, and you just cloned a fresh copy using
###
###   git clone --mirror https://github.com/academy-of-behavior-change/ciberlite
###
### Then you can delete all comma separated values (*.csv) files from the
### git history  using:
###
###   java -jar B:\Apps\bfg\bfg-1.13.0.jar --delete-files *.csv ciberlite.git
###
### Then run, as instructed by bfg:
###
###   cd ciberlite.git
###   git reflog expire --expire=now --all && git gc --prune=now --aggressive
###   git push
###
########################################################################

### Get a list of all data files in data directory
privateDataFiles <-
  list.files(dataPath);

### Select only those matching the regular expression for
### Open University data files
privateDataFiles <-
  grep(privateOUdataFileRegEx,
       privateDataFiles,
       value=TRUE);

dataDeletionVarName <- paste0(dataDeletionVarCode,
                              "_",
                              dataDeletionSubQuestionCode);

### Loop through the files
for (currentFilename in privateDataFiles) {
  
  ### Run within local, temporary namespace (so that all variables
  ### are deleted afterwards)
  local({
  
    ### First read in a temporary version of the data
    dat <-
      importLimeSurveyData(datafile = file.path(dataPath,
                                                currentFilename),
                           datafileRegEx = privateOUdataFileRegEx,
                           scriptfile = file.path(dataPath,
                                                  OUdataLoadScriptName),
                           categoricalQuestions = categoricalQuestions);
    
    ### Then get the position of the variable used to indicate whether
    ### data should be deleted:
    dataDeletionVarIndex <-
      grep(dataDeletionVarName, names(dat));
    
    ### Then construct the regular expression for matching the lines in
    ### the dataset that contain the data of participants who indicated
    ### they wanted their data deleted. A regular expression of the
    ### following form is constructed:
    ###
    ### (?:"[^"]*",){75}"2"
    ###
    ### The '75' is the index minus one, and the '2' the value indicating
    ### that data should be deleted. This regular expression matches any
    ### value between a pair of double quotes followed by a comma exactly
    ### 75 times; then matches a '2' between pair of double quotes. This
    ### pair of double quotes contains the value of the 76th variable (so,
    ### in this example, the value of the variable indicating whether data
    ### should be deleted), and therefore, this regular expression matches
    ### all lines containing data that should be deleted.
    
    dataDeletionRegEx <-
      paste0('(?:"[^"]*",){',
             dataDeletionVarIndex-1,
             '}"',
             dataDeletionVarValue,
             '"');

    ### Then read the datafile as character vector
    fullPrivateDataFile <-
      readLines(file.path(dataPath,
                          currentFilename));
    cat0("\n\nRead data file '", currentFilename, "'.\n\n");

    ### Get indices of lines that have to be deleted
    linesToDelete <- grep(dataDeletionRegEx,
                          fullPrivateDataFile);
    
    ### Log deletion
    cat0("Identified ", length(linesToDelete), " participants who ",
         "indicated they want their data to be deleted, specifically, ",
         "the following lines of the original raw dataset:\n\n",
         vecTxtQ(linesToDelete));
    
    ### Delete those lines
    fullPrivateDataFile <- fullPrivateDataFile[-linesToDelete];

    ### Construct new filename to write public version of data to
    newTmpFilename <- sub(privateFileIdentificationString,
                          publicFileIdentificationString,
                          currentFilename,
                          fixed=TRUE);
    
    ### Store new datafile
    writeLines(fullPrivateDataFile,
               file.path(dataPath,
                         newTmpFilename));

    cat0("\n\nStored data file '", newTmpFilename, "'.\n\n");

  });  ### End local namespace

}

########################################################################
### Import data from Open University survey
########################################################################

dat_ou.raw <-
  importLimeSurveyData(dataPath = dataPath,
                       datafileRegEx = publicOUdataFileRegEx,
                       scriptfile = file.path(dataPath,
                                              OUdataLoadScriptName),
                       categoricalQuestions = categoricalQuestions);

### Verify that no entries were read where people indicated they wanted
### their data removed
if (any(dat_ou.raw[, dataDeletionVarName]==dataDeletionVarValue, na.rm=TRUE)) {
  stop("The public data contains data from people who indicated they ",
       "wanted their data to be removed!");
} else {
  ### Delete variable storing whether people want their data deleted,
  ### so that the data can be easily merged with the dataset from
  ### ondrzk.nl
  dat_ou.raw[, grepl(dataDeletionVarCode,
                     names(dat_ou.raw))] <- NULL;
}

########################################################################
### Import data from separate online survey
########################################################################

dat_ondrzk.raw <-
  importLimeSurveyData(dataPath = dataPath,
                       datafileRegEx = ondrzkDataFileRegEx,
                       scriptfile = file.path(dataPath,
                                              ondrzkDataLoadScriptName),
                       categoricalQuestions = categoricalQuestions);

########################################################################
### Paper-and-pencil survey
########################################################################

### Save first two lines of 'onderzk' data as example for
### data entry of paper-and-pencil questionnaires
dataEntryTemplateFile <-
  file.path(processedDataPath,
            "data-entry-template.ods");
if (file.exists(dataEntryTemplateFile)) {
  unlink(dataEntryTemplateFile)
}
write_ods(dat_ondrzk.raw[1:2, 7:75],
          dataEntryTemplateFile);

########################################################################
### Data merging and aggregations
########################################################################

### Because these are different versions of LimeSurvey, the timing
### variables are named differently, so copy the column names
if (ncol(dat_ondrzk.raw) != ncol(dat_ou.raw)) {
  stop("Data files to merge have different numbers of columns!");
} else {
  names(dat_ondrzk.raw) <- names(dat_ou.raw);
}

### Merge data files
dat <- rbind(dat_ou.raw, dat_ondrzk.raw);

### Export merged datafile
write.csv(dat,
          file.path(processedDataPath,
                    "ciberlite-data--merged-public-raw.csv"));

```



```{r}
### Add variables names of the determinants' measures and compute
### means where necessary
for (i in seq_along(detStruct)) {
  detStructAddVarNames(detStruct[[i]], names(dat));
  dat <- detStructComputeScales(detStruct[[i]],
                                dat);
}

lapply(dat[, grepl('attitude', names(dat))], mean, na.rm=TRUE);
lapply(dat[, grepl('perceivedNorm', names(dat))], mean, na.rm=TRUE);
lapply(dat[, grepl('perceivedBehavioralControl', names(dat))], mean, na.rm=TRUE);

CIBERlite <- function(data,
                      determinants,
                      targets,
                      determinantOrder = NULL,
                      determinantLabels = NULL,
                      title=NULL,
                      conf.level = list(means = 0.9999,
                                        associations = 0.95),
                      scaleRange = NULL,
                      determinantAesthetics = list(fill = 'black',
                                                   color=NA,
                                                   alpha=.5),
                      subDeterminantAesthetics = list(fill = 'black',
                                                      color=NA,
                                                      alpha=.5)) {

  if (is.list(determinants)) {
    subDeterminantNames <- unlist(determinants);
    determinantNames <- names(determinants);
  } else {
    subDeterminantNames <- c();
    determinantNames <- determinants;
  }
  if (is.null(determinantOrder)) {
    determinantOrder <- seq_along(determinantNames);
  }
  
  ### Select relevant rows from dataset
  dat <- data[, c(targets, determinantNames, subDeterminantNames)];
  
  ### Set minimum and maximum for the used scales, if not provided
  if (is.null(scaleRange)) {
    scaleRange <- c(min(dat[, c(determinantNames, subDeterminantNames)], na.rm=TRUE),
                    max(dat[, c(determinantNames, subDeterminantNames)], na.rm=TRUE));
  }
  
  if (getOption('ufs.debug', FALSE)) {
    cat("\n", repStr("-", 50), "\n");
    print(determinantNames);
    print(subDeterminantNames);
    print(determinantOrder);
    print(scaleRange);
  }
  
  print(dim(is.na(dat[, c(determinantNames, subDeterminantNames)])));
  print((scaleRange[2] - scaleRange[1]));
  print(class(dim(((dat[, c(determinantNames, subDeterminantNames)] - scaleRange[1]) /
              (scaleRange[2] - scaleRange[1])))));
  
  ### Translate subdeterminants and determinants to 0-1 range
  dat[, c(determinantNames, subDeterminantNames)] <-
    ((dat[, c(determinantNames, subDeterminantNames)] - scaleRange[1]) /
              (scaleRange[2] - scaleRange[1]));
  
  if (is.list(determinants)) {
    ### We also have subdeterminants, so also get the means for those.
    
    subDeterminantDat<- sapply(dat[, subDeterminantNames],
                               function(x) {
                                 return(c(mean = mean(x, na.rm=TRUE),
                                          sd = sd(x, na.rm=TRUE)));
                               }) %>% t %>% as.data.frame;
    subDeterminantDat$subdeterminant <- row.names(subDeterminantDat);
    subDeterminantDat$determinant <- rep(determinantNames,
                                         sapply(determinants, length));
    subDeterminantDat$xPos <- rep(determinantOrder,
                                  sapply(determinants, length));
  }

  determinantDat <- sapply(dat[, determinantNames],
                           function(x) {
                             return(c(mean = mean(x, na.rm=TRUE),
                                      sd = sd(x, na.rm=TRUE)));
                           }) %>% t %>% as.data.frame;
  determinantDat$determinant <- row.names(determinantDat);
  determinantDat$xPos <- determinantOrder;
  
  if (getOption('ufs.debug', FALSE)) {
    print(determinantDat);
    print(subDeterminantDat);
  }
  
  if (is.null(determinantLabels)) {
    determinantLabels <- determinantNames;
  }
  
  ggplot() +
    geom_hline(yintercept = c(0, 1),
               color="black") +
    geom_bar(data = subDeterminantDat,
             aes_string(x = 'xPos',
                        y = 'mean',
                        group = 'subdeterminant'),
             stat='identity',
             position='dodge',
             fill=subDeterminantAesthetics$fill,
             color=subDeterminantAesthetics$color,
             alpha=subDeterminantAesthetics$alpha) +
    geom_bar(data = determinantDat,
             aes_string(x = 'xPos',
                        y = 'mean'),
             stat='identity',
             position='identity',
             fill=determinantAesthetics$fill,
             color=determinantAesthetics$color,
             alpha=determinantAesthetics$alpha) +
    theme_minimal() +
    coord_cartesian(ylim=c(0,1)) +
    scale_x_continuous(breaks=determinantOrder,
                       labels=determinantLabels) +
    ggtitle(title) +
    xlab(NULL) +
    ylab(NULL);
}

CIBERlitePlots <- lapply(seq_along(detStruct),
                         function(i) {
                           behaviorName <- detStruct[[i]]$behaviorRegEx;
                           detStructVars <-
                             detStruct[[i]]$Get('varNames', filterFun=isLeaf);
                           ### Set name to variable name of overarching determinant
                           names(detStructVars) <-
                             detStruct[[i]]$Get("scaleVarName", filterFun=isLeaf);
                           return(CIBERlite(dat,
                                            determinants=detStructVars,
                                            determinantLabels=c('Att', 'PN', 'PBC'),
                                            scaleRange=c(1,5),
                                            targets=detStruct[[i]]$intention$scaleVarName) +
                                    ggtitle(behaviorName));
                         });

grid.arrange(grobs=CIBERlitePlots, ncol=4);

### Correlation between the two sub-determinants

cor(dat[, unlist(detStruct[[1]]$intention$perceivedNorm$varNames)], use='complete');

```
