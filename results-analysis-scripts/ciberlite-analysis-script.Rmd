---
title: "CIBERlite"
author: "Gjalt-Jorn Peters & Rik Crutzen"
date: "29 January 2018"
output: html_document
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE);
options(ufs.debug = FALSE);

require('userfriendlyscience');
safeRequire('here');
safeRequire('data.tree');
safeRequire('tidyverse');
safeRequire('gridExtra');
safeRequire('readODS');

dataPath <- here::here('results-data-raw');
processedDataPath <- here::here('results-data-processed');
privateOUdataFileRegEx <- 'survey_722821_R_data_file_\\[PRIVATE-OU-version]';
publicOUdataFileRegEx <- 'survey_722821_R_data_file_\\[PUBLIC-OU-version]';
OUdataLoadScriptName <- 'survey_722821_R_syntax_file_[OU-version].R';

ondrzkDataFileRegEx <- 'survey_722821_R_data_file_\\[ondrzk-version]';
ondrzkDataLoadScriptName <- 'survey_722821_R_syntax_file_[ondrzk-version].R';

categoricalQuestions <- c('sex',
                          'education');

dataDeletionVarName <- "dataMustBeDeleted_delete";
dataDeletionVarValue <- "2";
privateFileIdentificationString <- "PRIVATE-";
publicFileIdentificationString <- "PUBLIC-";

behaviors <- c("coffee", "publicTransport",
               "runRedLight", "wasteSeparation",
               "conSomebody", "marathon",
               "longShower", "brushingTeeth");

detStruct <-
  lapply(behaviors,
         function(behav) {
  return(determinantStructure(behav,
                              list(behaviorRegEx = behav),
                              determinantVar("intention",
                                             "intention",
                                             determinantVar("attitude",
                                                            "att"),
                                             determinantVar("perceivedNorm",
                                                            "pn"),
                                             determinantVar("perceivedBehavioralControl",
                                                            "pbc"))));
});

########################################################################
### Import data from Open University survey
########################################################################

dat_ou.raw <-
  importLimeSurveyData(dataPath = dataPath,
                       datafileRegEx = OUdataFileRegEx,
                       scriptfile = file.path(dataPath,
                                              OUdataLoadScriptName),
                       categoricalQuestions = categoricalQuestions);

########################################################################
### Delete data from students who indicated they want their data
### destroyed
### (note that the original data file is excluded using .gitignore)
########################################################################

### Note: if you ever accidently commit private data to git, this can
### be removed using bfg, see:
###   https://help.github.com/articles/removing-sensitive-data-from-a-repository/
###   https://rtyley.github.io/bfg-repo-cleaner/
### For example, assuming you have version 1.13 installed in the
### directory B:\Apps\bfg, and you just 

### First get the position of the variable used to indicate whether
### data should be deleted:
dataDeletionVarIndex <-
  grep(dataDeletionVarName, names(dat));

### Then construct the regular expression for matching the lines in
### the dataset that contain the data of participants who indicated
### they wanted their data deleted. A regular expression of the
### following form is constructed:
###
### (?:"[^"]*",){75}"2"
###
### The '75' is the index minus one, and the '2' the value indicating
### that data should be deleted. This regular expression matches any
### value between a pair of double quotes followed by a comma exactly
### 75 times; then matches a '2' between pair of double quotes. This
### pair of double quotes contains the value of the 76th variable (so,
### in this example, the value of the variable indicating whether data
### should be deleted), and therefore, this regular expression matches
### all lines containing data that should be deleted.

dataDeletionRegEx <-
  paste0('(?:"[^"]*",){',
         dataDeletionVarIndex-1,
         '}"',
         dataDeletionVarValue,
         '"');

### Get a list of all data files in data directory
filesToDeleteDataFrom <-
  list.files(dataPath);

### Select only those matching the regular expression for
### Open University data files
filesToDeleteDataFrom <-
  grep(privateOUdataFileRegEx,
       filesToDeleteDataFrom,
       value=TRUE);

### Loop through the files
for (currentFilename in filesToDeleteDataFrom) {
  ### Read file
  tmpFile <-
    readLines(file.path(dataPath,
                        currentFilename));
  
  ### Construct new filename to write public version of data to
  newTmpFilename <- sub(privateFileIdentificationString,
                        publicFileIdentificationString,
                        currentFilename,
                        fixed=TRUE);
  
}



########################################################################
### Import data from separate online survey
########################################################################

dat_ondrzk.raw <-
  importLimeSurveyData(dataPath = dataPath,
                       datafileRegEx = ondrzkDataFileRegEx,
                       scriptfile = file.path(dataPath,
                                              ondrzkDataLoadScriptName),
                       categoricalQuestions = categoricalQuestions);

########################################################################
### Paper-and-pencil survey
########################################################################

### Save first two lines of 'onderzk' data as example for
### data entry of paper-and-pencil questionnaires
dataEntryTemplateFile <-
  file.path(processedDataPath,
            "data-entry-template.ods");
if (file.exists(dataEntryTemplateFile)) {
  unlink(dataEntryTemplateFile)
}
write_ods(dat_ondrzk.raw[1:2, 7:75],
          dataEntryTemplateFile);

########################################################################
### Data merging and aggregations
########################################################################

### Merge data files
dat <- dat_ou.raw;

### Add variables names of the determinants' measures and compute
### means where necessary
for (i in seq_along(detStruct)) {
  detStructAddVarNames(detStruct[[i]], names(dat));
  dat <- detStructComputeScales(detStruct[[i]],
                                dat);
}

lapply(dat[, grepl('attitude', names(dat))], mean, na.rm=TRUE);
lapply(dat[, grepl('perceivedNorm', names(dat))], mean, na.rm=TRUE);
lapply(dat[, grepl('perceivedBehavioralControl', names(dat))], mean, na.rm=TRUE);

CIBERlite <- function(data,
                      determinants,
                      targets,
                      determinantOrder = NULL,
                      determinantLabels = NULL,
                      title=NULL,
                      conf.level = list(means = 0.9999,
                                        associations = 0.95),
                      scaleRange = NULL,
                      determinantAesthetics = list(fill = 'black',
                                                   color=NA,
                                                   alpha=.5),
                      subDeterminantAesthetics = list(fill = 'black',
                                                      color=NA,
                                                      alpha=.5)) {

  if (is.list(determinants)) {
    subDeterminantNames <- unlist(determinants);
    determinantNames <- names(determinants);
  } else {
    subDeterminantNames <- c();
    determinantNames <- determinants;
  }
  if (is.null(determinantOrder)) {
    determinantOrder <- seq_along(determinantNames);
  }
  
  ### Select relevant rows from dataset
  dat <- data[, c(targets, determinantNames, subDeterminantNames)];
  
  ### Set minimum and maximum for the used scales, if not provided
  if (is.null(scaleRange)) {
    scaleRange <- c(min(dat[, c(determinantNames, subDeterminantNames)], na.rm=TRUE),
                    max(dat[, c(determinantNames, subDeterminantNames)], na.rm=TRUE));
  }
  
  if (getOption('ufs.debug', FALSE)) {
    cat("\n", repStr("-", 50), "\n");
    print(determinantNames);
    print(subDeterminantNames);
    print(determinantOrder);
    print(scaleRange);
  }
  
  print(dim(is.na(dat[, c(determinantNames, subDeterminantNames)])));
  print((scaleRange[2] - scaleRange[1]));
  print(class(dim(((dat[, c(determinantNames, subDeterminantNames)] - scaleRange[1]) /
              (scaleRange[2] - scaleRange[1])))));
  
  ### Translate subdeterminants and determinants to 0-1 range
  dat[, c(determinantNames, subDeterminantNames)] <-
    ((dat[, c(determinantNames, subDeterminantNames)] - scaleRange[1]) /
              (scaleRange[2] - scaleRange[1]));
  
  if (is.list(determinants)) {
    ### We also have subdeterminants, so also get the means for those.
    
    subDeterminantDat<- sapply(dat[, subDeterminantNames],
                               function(x) {
                                 return(c(mean = mean(x, na.rm=TRUE),
                                          sd = sd(x, na.rm=TRUE)));
                               }) %>% t %>% as.data.frame;
    subDeterminantDat$subdeterminant <- row.names(subDeterminantDat);
    subDeterminantDat$determinant <- rep(determinantNames,
                                         sapply(determinants, length));
    subDeterminantDat$xPos <- rep(determinantOrder,
                                  sapply(determinants, length));
  }

  determinantDat <- sapply(dat[, determinantNames],
                           function(x) {
                             return(c(mean = mean(x, na.rm=TRUE),
                                      sd = sd(x, na.rm=TRUE)));
                           }) %>% t %>% as.data.frame;
  determinantDat$determinant <- row.names(determinantDat);
  determinantDat$xPos <- determinantOrder;
  
  if (getOption('ufs.debug', FALSE)) {
    print(determinantDat);
    print(subDeterminantDat);
  }
  
  if (is.null(determinantLabels)) {
    determinantLabels <- determinantNames;
  }
  
  ggplot() +
    geom_hline(yintercept = c(0, 1),
               color="black") +
    geom_bar(data = subDeterminantDat,
             aes_string(x = 'xPos',
                        y = 'mean',
                        group = 'subdeterminant'),
             stat='identity',
             position='dodge',
             fill=subDeterminantAesthetics$fill,
             color=subDeterminantAesthetics$color,
             alpha=subDeterminantAesthetics$alpha) +
    geom_bar(data = determinantDat,
             aes_string(x = 'xPos',
                        y = 'mean'),
             stat='identity',
             position='identity',
             fill=determinantAesthetics$fill,
             color=determinantAesthetics$color,
             alpha=determinantAesthetics$alpha) +
    theme_minimal() +
    coord_cartesian(ylim=c(0,1)) +
    scale_x_continuous(breaks=determinantOrder,
                       labels=determinantLabels) +
    ggtitle(title) +
    xlab(NULL) +
    ylab(NULL);
}

CIBERlitePlots <- lapply(seq_along(detStruct),
                         function(i) {
                           behaviorName <- detStruct[[i]]$behaviorRegEx;
                           detStructVars <-
                             detStruct[[i]]$Get('varNames', filterFun=isLeaf);
                           ### Set name to variable name of overarching determinant
                           names(detStructVars) <-
                             detStruct[[i]]$Get("scaleVarName", filterFun=isLeaf);
                           return(CIBERlite(dat,
                                            determinants=detStructVars,
                                            determinantLabels=c('Att', 'PN', 'PBC'),
                                            scaleRange=c(1,5),
                                            targets=detStruct[[i]]$intention$scaleVarName) +
                                    ggtitle(behaviorName));
                         });

grid.arrange(grobs=CIBERlitePlots, ncol=4);

### Correlation between the two sub-determinants

cor(dat[, unlist(detStruct[[1]]$intention$perceivedNorm$varNames)], use='complete');


```
